
.. _lexical:

**********************************
词法分析 (Lexical analysis) 
**********************************

.. index:: lexical analysis, parser, token

A Python program is read by a *parser*.  Input to the parser is a stream of
*tokens*, generated by the *lexical analyzer*.  This chapter describes how the
lexical analyzer breaks a file into tokens.

Python 程序被*语法分析器*所读入.  输入到解析器的是由*词法分析器*所生成的*标识符*
流.  本章描述了词法分析器如何把一个文件转换为标识符.

Python reads program text as Unicode code points; the encoding of a source file
can be given by an encoding declaration and defaults to UTF-8, see :pep:`3120`
for details.  If the source file cannot be decoded, a :exc:`SyntaxError` is
raised.

Python 读取 Unicode 编码的程序文本; 源文件的编码器可以通过编码声明来给出, 默
认是 UTF-8, 详见 :pep:`3120`.  如果源文件无法被解码, 一个 :exc:`SyntaxError` 错误
就会被抛出.


.. _line-structure:

行结构 (Line structure) 
=========================

.. index:: line structure

A Python program is divided into a number of *logical lines*.

Python 程序被分割成一些*逻辑行*.


.. _logical-lines:

逻辑行 (Logical lines) 
-------------------------

.. index:: logical line, physical line, line joining, NEWLINE token

The end of a logical line is represented by the token NEWLINE.  Statements
cannot cross logical line boundaries except where NEWLINE is allowed by the
syntax (e.g., between statements in compound statements). A logical line is
constructed from one or more *physical lines* by following the explicit or
implicit *line joining* rules.

每一逻辑行结束的标志是 NEWLINE 标识符.  语句一般不能跨越几个逻辑行, 除非语法
允许在语句中出现 NEWLINE (例如, 复合语句中的语句之间). 每一逻辑行可以通过遵守
显式或隐式*加入行*规则由一个或更多物理行所构成.


.. _physical-lines:

物理行 (Physical lines) 
--------------------------

A physical line is a sequence of characters terminated by an end-of-line
sequence.  In source files, any of the standard platform line termination
sequences can be used - the Unix form using ASCII LF (linefeed), the Windows
form using the ASCII sequence CR LF (return followed by linefeed), or the old
Macintosh form using the ASCII CR (return) character.  All of these forms can be
used equally, regardless of platform.

物理行是由 end-of-line 序列终止的字符序列.  在源文件中, 以下任和标准平台行终结符
序列都可以被使用 - 使用 ASCII LF (换行) 的 Unix 格式, 使用 ASCII 序列 CR LF (返回
紧随着换行) 的 Windows 平台, 或者是使用 ASCII CR (返回) 的 old Macintosh 格式.

When embedding Python, source code strings should be passed to Python APIs using
the standard C conventions for newline characters (the ``\n`` character,
representing ASCII LF, is the line terminator).

当嵌入 Python 时候, 传入 Python APIs 的源代码字符串应当使用标准 C 约定的换行符 (
``\n`` 字符, 代表 ASCII LF, 是行终结符). 


.. _comments:

注释 (Comments) 
------------------

.. index:: comment, hash character

A comment starts with a hash character (``#``) that is not part of a string
literal, and ends at the end of the physical line.  A comment signifies the end
of the logical line unless the implicit line joining rules are invoked. Comments
are ignored by the syntax; they are not tokens.

注释以不在字符串里的井号 (``#``) 开始, 该物理行的尾端结束. 一个注释一般就意味着逻
辑行的结束, 除非一个隐式的加入行规则被调用. 按照语法来讲, 注释会被忽略掉; 它们不
是标识符.


.. _encodings:

编码声明 (Encoding declarations) 
-----------------------------------

.. index:: source character set, encodings

If a comment in the first or second line of the Python script matches the
regular expression ``coding[=:]\s*([-\w.]+)``, this comment is processed as an
encoding declaration; the first group of this expression names the encoding of
the source code file. The recommended forms of this expression are ::

   # -*- coding: <encoding-name> -*-

which is recognized also by GNU Emacs, and ::

   # vim:fileencoding=<encoding-name>

which is recognized by Bram Moolenaar's VIM.

如果 Python 脚本的第一行或第二行的注释匹配 ``coding[=:]\s*([-\w.]+)`` 正则表达式, 
那么这个注释就被当成编码声明来处理; 这个表达式的第一部分告诉了源代码文件的编码器. 
该表达式推荐的格式是 ::

   # -*- coding: <encoding-name> -*-

他也被 GNU Emacs 推荐, and ::

   # vim:fileencoding=<encoding-name>

它也被 Bram Moolenaar 的 VIM 推荐.

If no encoding declaration is found, the default encoding is UTF-8.  In
addition, if the first bytes of the file are the UTF-8 byte-order mark
(``b'\xef\xbb\xbf'``), the declared file encoding is UTF-8 (this is supported,
among others, by Microsoft's :program:`notepad`).

如果找不到任何编码声明, 那么就默认编码器是 UTF-8.  此外, 如果文件的头几个字节是 
UTF-8 BOM (``b'\xef\xbb\xbf'``), 那么声明的编码器就是 UTF-8 (这是被一些支持的程
序支持的, 其中包含 Microsoft 的 :program:`记事本`).

If an encoding is declared, the encoding name must be recognized by Python. The
encoding is used for all lexical analysis, including string literals, comments
and identifiers. The encoding declaration must appear on a line of its own.

如果声明了一个编码器, 那么这个编码器的名字一定要能被 Python 辨认. 该编码器将在所
有的词法分析中使用, 包含字符串, 注释和标识符. 编码声明必须出现在所在的行里.

.. XXX there should be a list of supported encodings.


.. _explicit-joining:

显式行连接 (Explicit line joining) 
---------------------------------------------------------

.. index:: physical line, line joining, line continuation, backslash character

Two or more physical lines may be joined into logical lines using backslash
characters (``\``), as follows: when a physical line ends in a backslash that is
not part of a string literal or comment, it is joined with the following forming
a single logical line, deleting the backslash and the following end-of-line
character.  For example::

   if 1900 < year < 2100 and 1 <= month <= 12 \
      and 1 <= day <= 31 and 0 <= hour < 24 \
      and 0 <= minute < 60 and 0 <= second < 60:   # Looks like a valid date
           return 1

两个以上的物理行可以通过使用反斜杠字符 (``\``) 加入到逻辑行, 如下: 当一个物理行以
一个不在注释或字符串里的反斜杠结尾, 它将删除反斜杠和行终结符, 加入到随后以形成单
一的逻辑行.  例如::

   if 1900 < year < 2100 and 1 <= month <= 12 \
      and 1 <= day <= 31 and 0 <= hour < 24 \
      and 0 <= minute < 60 and 0 <= second < 60:   # 看起来像个有效的时间
           return 1
		   
A line ending in a backslash cannot carry a comment.  A backslash does not
continue a comment.  A backslash does not continue a token except for string
literals (i.e., tokens other than string literals cannot be split across
physical lines using a backslash).  A backslash is illegal elsewhere on a line
outside a string literal.

以反斜杠结尾的行不能跟着注释.  反斜杠不能继续一个注释.  反斜杠一般不能继续一个标
识符, 除非是字符串 (例如, 除字符串以外的标识符不能通过使用反斜杠分隔成几个物理行). 
A backslash is illegal elsewhere on a line outside a string literal.


.. _implicit-joining:

隐式行连接 (Implicit line joining) 
--------------------------------------------------------

Expressions in parentheses, square brackets or curly braces can be split over
more than one physical line without using backslashes. For example::

   month_names = ['Januari', 'Februari', 'Maart',      # These are the
                  'April',   'Mei',      'Juni',       # Dutch names
                  'Juli',    'Augustus', 'September',  # for the months
                  'Oktober', 'November', 'December']   # of the year

在圆括号, 方括号, 大括号里的表达式可以被分割成多行而不需要使用反斜杠. 例如::

   month_names = ['Januari', 'Februari', 'Maart',      # 这是一
                  'April',   'Mei',      'Juni',       # 年中月
                  'Juli',    'Augustus', 'September',  # 份的荷
                  'Oktober', 'November', 'December']   # 兰语名字
				  
Implicitly continued lines can carry comments.  The indentation of the
continuation lines is not important.  Blank continuation lines are allowed.
There is no NEWLINE token between implicit continuation lines.  Implicitly
continued lines can also occur within triple-quoted strings (see below); in that
case they cannot carry comments.

隐式继续行可以带注释.  


.. _blank-lines:

空行 (Blank lines) 
----------------------------------

.. index:: single: blank line

A logical line that contains only spaces, tabs, formfeeds and possibly a
comment, is ignored (i.e., no NEWLINE token is generated).  During interactive
input of statements, handling of a blank line may differ depending on the
implementation of the read-eval-print loop.  In the standard interactive
interpreter, an entirely blank logical line (i.e. one containing not even
whitespace or a comment) terminates a multi-line statement.

只含有空格、制表符、进纸符和一个可选注释的逻辑行, 在解析过程中是被忽略的 (即不会产生对应的NEWLINE语言符号). 在语句进行交互式输入时, 对空行的处理可能不同, 这依赖于 "输入-计算-输出"  (read-eval-print) 循环的实现方式. 在标准交互解释器中, 一个纯粹的空行 (即不包括任何东西,甚至注释和空白) 才会结束多行语句. 

.. _indentation:

缩进 (Indentation) 
------------------------------------

.. index:: indentation, leading whitespace, space, tab, grouping, statement grouping

Leading whitespace (spaces and tabs) at the beginning of a logical line is used
to compute the indentation level of the line, which in turn is used to determine
the grouping of statements.

逻辑行的前导空白 (空格和制表符) 用于计算行的缩进层次, 缩进层次然后用于语句的分组. 

Tabs are replaced (from left to right) by one to eight spaces such that the
total number of characters up to and including the replacement is a multiple of
eight (this is intended to be the same rule as used by Unix).  The total number
of spaces preceding the first non-blank character then determines the line's
indentation.  Indentation cannot be split over multiple physical lines using
backslashes; the whitespace up to the first backslash determines the
indentation.

首先, 制表符被转换成 (从左到右) 一至八个空格, 这样直到包括替换部分的字符总数达到八的倍数 (这是为了与UNIX的规则保持一致. 然后, 根据首个非空白字符前的空格总数计算行的缩进层次.  "缩进" 是不能用反斜线跨物理行接续的. 只有反斜线之前的空白字符才用于确定缩进层次. 

Indentation is rejected as inconsistent if a source file mixes tabs and spaces
in a way that makes the meaning dependent on the worth of a tab in spaces; a
:exc:`TabError` is raised in that case.

如果源文件混合使用了制表符和空格, 并且缩进的意义依赖于制表符的空格长度的话, 那么这种缩进会以不一致为原因被拒绝, 并会抛出 :exc:`TabError` 异常. 

**Cross-platform compatibility note:** because of the nature of text editors on
non-UNIX platforms, it is unwise to use a mixture of spaces and tabs for the
indentation in a single source file.  It should also be noted that different
platforms may explicitly limit the maximum indentation level.

**跨平台兼容性注意: ** 由于在非UNIX平台上的文本编辑器特性, 在单个源文件里使用混合空格和制表符的缩进是不明智的. 另一个值得注意的地方是不同平台可能明确地限制了最大缩进层次. 

A formfeed character may be present at the start of the line; it will be ignored
for the indentation calculations above.  Formfeed characters occurring elsewhere
in the leading whitespace have an undefined effect (for instance, they may reset
the space count to zero).

换页符 (formfeed) 可以出现在行首, 但以上介绍的缩进计算过程会忽略它. 在行前置空白的其它位置上出现的换页符会导致未定义的行为 (例如, 它可能使空格数重置为零) . 

.. index:: INDENT token, DEDENT token

The indentation levels of consecutive lines are used to generate INDENT and
DEDENT tokens, using a stack, as follows.

每种连续行缩进的层次都会产生语言符号INDENT和DEDENT, 这里使用了堆栈数据结构, 如下所述. 

Before the first line of the file is read, a single zero is pushed on the stack;
this will never be popped off again.  The numbers pushed on the stack will
always be strictly increasing from bottom to top.  At the beginning of each
logical line, the line's indentation level is compared to the top of the stack.
If it is equal, nothing happens. If it is larger, it is pushed on the stack, and
one INDENT token is generated.  If it is smaller, it *must* be one of the
numbers occurring on the stack; all numbers on the stack that are larger are
popped off, and for each number popped off a DEDENT token is generated.  At the
end of the file, a DEDENT token is generated for each number remaining on the
stack that is larger than zero.

在未读入文件第一行之前, 压入 (push) 内一个零, 它此后再也不会被弹出 (pop) . 所有压入堆栈中的数字都从底部向顶部增长. 在每个逻辑行的开头处, 它的缩进层次与栈顶比较, 如果两者相等则什么也不会发生; 如果它大于栈顶, 将其压入栈中, 并产生一个INDENT语言符号; 如果小于栈顶, 那么它的值应该已经出现于堆栈中, 堆栈中所有大于它的数都将被弹出, 并且每个都产生一个DEDENT语言符号. 到达文件尾时, 堆栈中大于零的数字都被弹出, 每弹出一个数字都会产生一个DEDENT语言符号. 

Here is an example of a correctly (though confusingly) indented piece of Python
code:

这是一个有着正确缩进格式的Python代码的例子 (虽然有点乱) ::

   def perm(l):
           # Compute the list of all permutations of l
       if len(l) <= 1:
                     return [l]
       r = []
       for i in range(len(l)):
                s = l[:i] + l[i+1:]
                p = perm(s)
                for x in p:
                 r.append(l[i:i+1] + x)
       return r

The following example shows various indentation errors::

    def perm(l):                       # error: first line indented
   for i in range(len(l)):             # error: not indented
       s = l[:i] + l[i+1:]
           p = perm(l[:i] + l[i+1:])   # error: unexpected indent
           for x in p:
                   r.append(l[i:i+1] + x)
               return r                # error: inconsistent dedent

(Actually, the first three errors are detected by the parser; only the last
error is found by the lexical analyzer --- the indentation of ``return r`` does
not match a level popped off the stack.)

 (事实上, 前三个错误是由解析器发现的. 仅仅最后一个错误是由词法分析器找到的 —— ``return r`` 的缩进层次与弹出堆栈的数不匹配. ) 

.. _whitespace:

语言符号间的空白 (Whitespace between tokens) 
--------------------------------------------------------------------------------

Except at the beginning of a logical line or in string literals, the whitespace
characters space, tab and formfeed can be used interchangeably to separate
tokens.  Whitespace is needed between two tokens only if their concatenation
could otherwise be interpreted as a different token (e.g., ab is one token, but
a b is two tokens).

除了位于在逻辑行开始处或者字符串当中, 空格, 制表符和进纸符这些空白字符可以等效地用于分隔语言符号 (token) . 只在两个符号在连接后会有其它含义时才需要使用空白分割它们, 例如, ab是一个符号,但a b是两个符号. 

.. _other-tokens:

其它语言符号 (Other tokens) 
===============================================

Besides NEWLINE, INDENT and DEDENT, the following categories of tokens exist:
*identifiers*, *keywords*, *literals*, *operators*, and *delimiters*. Whitespace
characters (other than line terminators, discussed earlier) are not tokens, but
serve to delimit tokens. Where ambiguity exists, a token comprises the longest
possible string that forms a legal token, when read from left to right.

除了NEWLINE、INDENT和DEDENT外, 还有以下几类语言符号:  *标识符* ,  *关键字* 、 *字面值* 、 *运算符* 和 *分隔符* . 空白不是语言符号 (除了断行符, 如前所述) , 但可以用于分隔语言符号. 如果在构造某语言符号可能存在歧义时, 就试图用尽量长的字符串 (从左至右读出的) 构造一个合法语言符号. 

.. _identifiers:

标识符和关键字 (Identifiers and keywords) 
=========================================================

.. index:: identifier, name

Identifiers (also referred to as *names*) are described by the following lexical
definitions.

标识符 (也称为 *名字* ) 由以下词法定义描述. 

The syntax of identifiers in Python is based on the Unicode standard annex
UAX-31, with elaboration and changes as defined below; see also :pep:`3131` for
further details.

下面介绍的Python标识符定义是在Unicode standard annex UAX-31的基础上加以修改而成的, 更多细节可以参考 :pep:`3131` . 

Within the ASCII range (U+0001..U+007F), the valid characters for identifiers
are the same as in Python 2.x: the uppercase and lowercase letters ``A`` through
``Z``, the underscore ``_`` and, except for the first character, the digits
``0`` through ``9``.

在ASCII范围(U+0001..U+007F)内, 标识符的有效字符与Python 2.x相同: 大小写字母 (A-Z) 、下划线, 以及不能作为标识符开始的数字 (0-9) . 

Python 3.0 introduces additional characters from outside the ASCII range (see
:pep:`3131`).  For these characters, the classification uses the version of the
Unicode Character Database as included in the :mod:`unicodedata` module.

Python 3.0引入了在ASCII范围之外额外字符 (参见 :pep:`3131` ) . 对于这些字符, 分类 (classification) 可以使用 :mod:`unicodedata` 模块中的Unicode Character Database. 

Identifiers are unlimited in length.  Case is significant.

标识符不限长度, 区分大小写. 

.. productionlist::
   identifier: `xid_start` `xid_continue`*
   id_start: <all characters in general categories Lu, Ll, Lt, Lm, Lo, Nl, the underscore, and characters with the Other_ID_Start property>
   id_continue: <all characters in `id_start`, plus characters in the categories Mn, Mc, Nd, Pc and others with the Other_ID_Continue property>
   xid_start: <all characters in `id_start` whose NFKC normalization is in "id_start xid_continue*">
   xid_continue: <all characters in `id_continue` whose NFKC normalization is in "id_continue*">

The Unicode category codes mentioned above stand for:

以上Unicode category code的缩写是: 

* *Lu* - uppercase letters
* *Ll* - lowercase letters
* *Lt* - titlecase letters
* *Lm* - modifier letters
* *Lo* - other letters
* *Nl* - letter numbers
* *Mn* - nonspacing marks
* *Mc* - spacing combining marks
* *Nd* - decimal numbers
* *Pc* - connector punctuations
* *Other_ID_Start* - explicit list of characters in `PropList.txt <http://unicode.org/Public/UNIDATA/PropList.txt>`_ to support backwards compatibility
* *Other_ID_Continue* - likewise

All identifiers are converted into the normal form NFKC while parsing; comparison
of identifiers is based on NFKC.

A non-normative HTML file listing all valid identifier characters for Unicode
4.1 can be found at

可以在这里找到一篇非标准的HTML文件列出了所有Unicode 4.1中有效的标识符字符: 

http://www.dcl.hpi.uni-potsdam.de/home/loewis/table-3131.html.


.. _keywords:

关键字
----------------------------------------

.. index::
   single: keyword
   single: reserved word

The following identifiers are used as reserved words, or *keywords* of the
language, and cannot be used as ordinary identifiers.  They must be spelled
exactly as written here:

以下标识符用作保留字, 或者叫做语言的 *关键字* , 它们不能作为普通标识符使用, 而且它们必须按如下拼写严格书写: 

.. sourcecode:: text

   False      class      finally    is         return
   None       continue   for        lambda     try
   True       def        from       nonlocal   while
   and        del        global     not        with
   as         elif       if         or         yield
   assert     else       import     pass
   break      except     in         raise

.. _id-classes:

保留的标识符类型 (Reserved classes of identifiers) 
---------------------------------------------------------------------------------------------

Certain classes of identifiers (besides keywords) have special meanings.  These
classes are identified by the patterns of leading and trailing underscore
characters:

除了关键字, 某些类型的标识符也具有特殊含义, 这种标识符一般都以下划线开始或结束: 

``_*``
   Not imported by ``from module import *``.  The special identifier ``_`` is used
   in the interactive interpreter to store the result of the last evaluation; it is
   stored in the :mod:`builtins` module.  When not in interactive mode, ``_``
   has no special meaning and is not defined. See section :ref:`import`.

   ``from moduls import *`` 不会导入这些符号. 在交互式解释器中, 特殊标识符 ``_`` 保存上次计算 (evaluation) 的结果, 这个符号在 :mod:`builtins` 模块之中. 在非交互方式时,  ``_`` 没有特殊含义, 而且是没有定义的. 参见 :ref:`import` 节. 

   .. note::

      The name ``_`` is often used in conjunction with internationalization;
      refer to the documentation for the :mod:`gettext` module for more
      information on this convention.      

      名字 ``_`` 通常用于国际化开发, 关于这个惯用法, 可以参考模块 :mod:`gettext` . 

``__*__``
   System-defined names. These names are defined by the interpreter and its
   implementation (including the standard library).  Current system names are
   discussed in the :ref:`specialnames` section and elsewhere.  More will likely
   be defined in future versions of Python.  *Any* use of ``__*__`` names, in
   any context, that does not follow explicitly documented use, is subject to
   breakage without warning.

   系统预定义的名字. 这种名字由解释器及其实现定义 (包括标准库) . 目前定义的系统名字在　:ref:`specialnames` 和其他地方有所介绍. Python的未来版本可能会引入更多的这种名字 . 对于*不*符合文档说明的 ``__*__`` 名字的用法, 可能会在以后版本中在没有任何警告的前提下失败. 

``__*``
   Class-private names.  Names in this category, when used within the context of a
   class definition, are re-written to use a mangled form to help avoid name
   clashes between "private" attributes of base and derived classes. See section
   :ref:`atom-identifiers`.

   类私有名字. 此类名字出现在类定义的上下文中. 为了避免基类与继承类的 "私有" 属性的名字冲突, 它们会被自动更名为其他名字 (mangled form) . 参考 :ref:`atom-identifiers` . 

.. _literals:

字面值 (Literals) 
========================

.. index:: literal, constant

Literals are notations for constant values of some built-in types.

字面值是某些内置类型的常量值的表示法. 

.. _strings:

字符串与字节的字面值 (String and Bytes literals) 
--------------------------------------------------------------------------------

.. index:: string literal, bytes literal, ASCII

String literals are described by the following lexical definitions:

字符串字面值由以下词法定义描述: 

.. productionlist::
   stringliteral: [`stringprefix`](`shortstring` | `longstring`)
   stringprefix: "r" | "R"
   shortstring: "'" `shortstringitem`* "'" | '"' `shortstringitem`* '"'
   longstring: "'''" `longstringitem`* "'''" | '"""' `longstringitem`* '"""'
   shortstringitem: `shortstringchar` | `stringescapeseq`
   longstringitem: `longstringchar` | `stringescapeseq`
   shortstringchar: <any source character except "\" or newline or the quote>
   longstringchar: <any source character except "\">
   stringescapeseq: "\" <any source character>

.. productionlist::
   bytesliteral: `bytesprefix`(`shortbytes` | `longbytes`)
   bytesprefix: "b" | "B" | "br" | "Br" | "bR" | "BR"
   shortbytes: "'" `shortbytesitem`* "'" | '"' `shortbytesitem`* '"'
   longbytes: "'''" `longbytesitem`* "'''" | '"""' `longbytesitem`* '"""'
   shortbytesitem: `shortbyteschar` | `bytesescapeseq`
   longbytesitem: `longbyteschar` | `bytesescapeseq`
   shortbyteschar: <any ASCII character except "\" or newline or the quote>
   longbyteschar: <any ASCII character except "\">
   bytesescapeseq: "\" <any ASCII character>

One syntactic restriction not indicated by these productions is that whitespace
is not allowed between the :token:`stringprefix` or :token:`bytesprefix` and the
rest of the literal. The source character set is defined by the encoding
declaration; it is UTF-8 if no encoding declaration is given in the source file;
see section :ref:`encodings`.

上面产生式中一个没有表示出来的语法限制是, 在 :token:`stringprefix` 或 :token:`bytesprefix` 与其余字面值之间不允许出现空白字符. 源代码的字符集由编码声明定义, 如果源文件内没有指定编码声明, 则默认为UTF-8, 参见 :ref:`encodings` . 

.. index:: triple-quoted string, Unicode Consortium, raw string

In plain English: Both types of literals can be enclosed in matching single quotes
(``'``) or double quotes (``"``).  They can also be enclosed in matching groups
of three single or double quotes (these are generally referred to as
*triple-quoted strings*).  The backslash (``\``) character is used to escape
characters that otherwise have a special meaning, such as newline, backslash
itself, or the quote character.

通俗地讲, 这两种字面值可以用单引号( ``' `` )或双引号( ``" `` )括住. 它们也可以用成对的三个单引号和双引号(这叫做 *三重引用串* ), 反斜线( ``\`` )可以用于引用其它有特殊含义的字符, 例如新行符、反斜线本身或者引用字符. 

Bytes literals are always prefixed with ``'b'`` or ``'B'``; they produce an
instance of the :class:`bytes` type instead of the :class:`str` type.  They
may only contain ASCII characters; bytes with a numeric value of 128 or greater
must be expressed with escapes.

字节字面值一定要以 ``'b'`` 或 ``'B'`` 开始, 这会产生一个:`bytes` 类的实例, 而不是 :class:`str` 的. 它只能包括ASCII字符, 数值等于或者超过128的字节必须用转义字符表达. 

Both string and bytes literals may optionally be prefixed with a letter ``'r'``
or ``'R'``; such strings are called :dfn:`raw strings` and treat backslashes as
literal characters.  As a result, in string literals, ``'\U'`` and ``'\u'``
escapes in raw strings are not treated specially.

字符串和字节字面值都可以用 ``' u' `` 和 ``' U' `` 开头, 这样的字符串字面值叫作 :dfn:`原始串 (raw strings) ` , 其中不对反斜线作转义处理, 因此, 原始串中的 ``'\U'`` 和 ``'\u'`` 不会得到特殊处理. 

In triple-quoted strings, unescaped newlines and quotes are allowed (and are
retained), except that three unescaped quotes in a row terminate the string.  (A
"quote" is the character used to open the string, i.e. either ``'`` or ``"``.)

在三重引用串中, 未转义新行和引用字符是允许的 (并且会被保留) , 除非三个连续的引用字符结束了该串.  (引用字符指用于开始字符串的字符, 如 ``' `` 和 ``" `` ) 

.. index:: physical line, escape sequence, Standard C, C

Unless an ``'r'`` or ``'R'`` prefix is present, escape sequences in strings are
interpreted according to rules similar to those used by Standard C.  The
recognized escape sequences are:

如果没有使用 ``' r' `` 或 ``' R' `` 前缀, 转义序列就按就按类似标准C那样解释, 可接受的转义序列见下表: 

+-----------------+---------------------------------+-------+
| Escape Sequence | Meaning                         | Notes |
+=================+=================================+=======+
| ``\newline``    | Backslash and newline ignored   |       |
+-----------------+---------------------------------+-------+
| ``\\``          | Backslash (``\``)               |       |
+-----------------+---------------------------------+-------+
| ``\'``          | Single quote (``'``)            |       |
+-----------------+---------------------------------+-------+
| ``\"``          | Double quote (``"``)            |       |
+-----------------+---------------------------------+-------+
| ``\a``          | ASCII Bell (BEL)                |       |
+-----------------+---------------------------------+-------+
| ``\b``          | ASCII Backspace (BS)            |       |
+-----------------+---------------------------------+-------+
| ``\f``          | ASCII Formfeed (FF)             |       |
+-----------------+---------------------------------+-------+
| ``\n``          | ASCII Linefeed (LF)             |       |
+-----------------+---------------------------------+-------+
| ``\r``          | ASCII Carriage Return (CR)      |       |
+-----------------+---------------------------------+-------+
| ``\t``          | ASCII Horizontal Tab (TAB)      |       |
+-----------------+---------------------------------+-------+
| ``\v``          | ASCII Vertical Tab (VT)         |       |
+-----------------+---------------------------------+-------+
| ``\ooo``        | Character with octal value      | (1,3) |
|                 | *ooo*                           |       |
+-----------------+---------------------------------+-------+
| ``\xhh``        | Character with hex value *hh*   | (2,3) |
+-----------------+---------------------------------+-------+

Escape sequences only recognized in string literals are:

只有字符串字面值才支持的转义字符有: 

+-----------------+---------------------------------+-------+
| Escape Sequence | Meaning                         | Notes |
+=================+=================================+=======+
| ``\N{name}``    | Character named *name* in the   |       |
|                 | Unicode database                |       |
+-----------------+---------------------------------+-------+
| ``\uxxxx``      | Character with 16-bit hex value | \(4)  |
|                 | *xxxx*                          |       |
+-----------------+---------------------------------+-------+
| ``\Uxxxxxxxx``  | Character with 32-bit hex value | \(5)  |
|                 | *xxxxxxxx*                      |       |
+-----------------+---------------------------------+-------+

Notes:

(1)
   As in Standard C, up to three octal digits are accepted.

   与C标准相同, 最多只接受三个八进制数字. 

(2)
   Unlike in Standard C, exactly two hex digits are required.

   不像C标准, 这里要求给全２个十六进制数字. 

(3)
   In a bytes literal, hexadecimal and octal escapes denote the byte with the
   given value. In a string literal, these escapes denote a Unicode character
   with the given value.

   在字节字面值中, 十六进制和八进制转义字符都是指定一个字节的值. 在字符串字面值中, 这些转义字符指定的是一个Unicode字符的值. 

(4)
   Individual code units which form parts of a surrogate pair can be encoded using
   this escape sequence.  Exactly four hex digits are required.

   任何构成部分surrogate pair的单独code unit都可以使用转义字符序列编码. 不像C标准, 这里要求给全４个十六进制数字. 

(5)
   Any Unicode character can be encoded this way, but characters outside the Basic
   Multilingual Plane (BMP) will be encoded using a surrogate pair if Python is
   compiled to use 16-bit code units (the default).  Exactly eight hex digits
   are required.

   任何Unicode字符都可以用这种方式编码, 但如果Python是按16位code unit编译的话 (默认) , 这里要求写全８个十六进制数字. 

.. index:: unrecognized escape sequence

Unlike Standard C, all unrecognized escape sequences are left in the string
unchanged, i.e., *the backslash is left in the string*.  (This behavior is
useful when debugging: if an escape sequence is mistyped, the resulting output
is more easily recognized as broken.)  It is also important to note that the
escape sequences only recognized in string literals fall into the category of
unrecognized escapes for bytes literals.

Even in a raw string, string quotes can be escaped with a backslash, but the
backslash remains in the string; for example, ``r"\""`` is a valid string
literal consisting of two characters: a backslash and a double quote; ``r"\"``
is not a valid string literal (even a raw string cannot end in an odd number of
backslashes).  Specifically, *a raw string cannot end in a single backslash*
(since the backslash would escape the following quote character).  Note also
that a single backslash followed by a newline is interpreted as those two
characters as part of the string, *not* as a line continuation.


即使在原始串中, 字符引用也可以使用反斜线转义, 但反斜线会保留在字符串中, 例如,  ``r"\""`` 是一个有效的字符串, 它由两个字符组成, 一个反斜线一个双引号; 而 ``r"\"`` 则不是 (甚至原始串也不能包括奇数个反斜线. 另外,  *原始串也不能以反斜线结束*  (因为反斜线会把后面的引用字符转义) . 同时, 也要注意在新行符后出现的反斜线, 会解释为串部分中的两个字符, 而 *不是* 续行处理. 
.. _string-catenation:

字符串字面值的连接 (String literal concatenation) 
------------------------------------------------------------------------------------

Multiple adjacent string or bytes literals (delimited by whitespace), possibly
using different quoting conventions, are allowed, and their meaning is the same
as their concatenation.  Thus, ``"hello" 'world'`` is equivalent to
``"helloworld"``.  This feature can be used to reduce the number of backslashes
needed, to split long strings conveniently across long lines, or even to add
comments to parts of strings, for example:

多个空白分隔的相邻字符串或者字节字面值, 可能使用了不同的引用习惯, 这是允许的, 并且它们在连接时含义是一样的. 因此, ``" hello"  'world'`` 等价于 ``" helloworld" `` . 这个功能可以用来减少需要的反斜线, 把跨越多行的长字符串, 甚至可以在串的某个部分加注释, 例如::

   re.compile("[A-Za-z_]"       # letter or underscore
              "[A-Za-z0-9_]*"   # letter, digit or underscore
             )

Note that this feature is defined at the syntactical level, but implemented at
compile time.  The '+' operator must be used to concatenate string expressions
at run time.  Also note that literal concatenation can use different quoting
styles for each component (even mixing raw strings and triple quoted strings).

注意这个功能是在语法层次上定义的, 但却是在编译时实现的. 在运行时连接字符串表达式必须使用" +" 运算符. 再次提醒, 在字面值连接时, 不同的引用字符可以混用, 甚至原始串与三重引用串也可以混合使用. 

.. _numbers:

数值型的字面值 (Numeric literals) 
----------------------------------------------------------------

.. index:: number, numeric literal, integer literal
   floating point literal, hexadecimal literal
   octal literal, binary literal, decimal literal, imaginary literal, complex literal

There are three types of numeric literals: integers, floating point numbers, and
imaginary numbers.  There are no complex literals (complex numbers can be formed
by adding a real number and an imaginary number).

有三种数值型字面值: 整数、浮点数和虚数. 没有复数类型的字面值, 复数可以用一个实数加上一个虚数的方法构造. 

Note that numeric literals do not include a sign; a phrase like ``-1`` is
actually an expression composed of the unary operator '``-``' and the literal
``1``.

注意数值型字面值并不包括正负号, 像 ``-1`` , 实际上是组合了一元运算符 '``-``' 和字面值 ``1`` 的一个表达式. 

.. _integers:

整数字面值 (Integer literals) 
-----------------------------------------------------

Integer literals are described by the following lexical definitions:

整数字面值由以下词法定义描述: 

.. productionlist::
   integer: `decimalinteger` | `octinteger` | `hexinteger` | `bininteger`
   decimalinteger: `nonzerodigit` `digit`* | "0"+
   nonzerodigit: "1"..."9"
   digit: "0"..."9"
   octinteger: "0" ("o" | "O") `octdigit`+
   hexinteger: "0" ("x" | "X") `hexdigit`+
   bininteger: "0" ("b" | "B") `bindigit`+
   octdigit: "0"..."7"
   hexdigit: `digit` | "a"..."f" | "A"..."F"
   bindigit: "0" | "1"

There is no limit for the length of integer literals apart from what can be
stored in available memory.

除了可用内存的容量限制, 整数长度没有其他限制. 

Note that leading zeros in a non-zero decimal number are not allowed. This is
for disambiguation with C-style octal literals, which Python used before version
3.0.

注意, 非零十进制数字中不允许用0作为前缀, 这种写法会与C语言风格的八进制字面值产生歧义 (用于3.0之前版本的Python) . 

Some examples of integer literals:

整数字面值的一些例子::

   7     2147483647                        0o177    0b100110111
   3     79228162514264337593543950336     0o377    0x100000000
         79228162514264337593543950336              0xdeadbeef


.. _floating:

浮点型字面值 (Floating point literals) 
---------------------------------------------------------------------

Floating point literals are described by the following lexical definitions:

浮点型的字面值可以用以下词法定义描述: 

.. productionlist::
   floatnumber: `pointfloat` | `exponentfloat`
   pointfloat: [`intpart`] `fraction` | `intpart` "."
   exponentfloat: (`intpart` | `pointfloat`) `exponent`
   intpart: `digit`+
   fraction: "." `digit`+
   exponent: ("e" | "E") ["+" | "-"] `digit`+

Note that the integer and exponent parts are always interpreted using radix 10.
For example, ``077e010`` is legal, and denotes the same number as ``77e10``. The
allowed range of floating point literals is implementation-dependent. Some
examples of floating point literals:

注意整数部分和指数部分都看作是十进制的. 例如,  ``077e010`` 是合法的, 它等价于 ``77e10`` . 浮点型字面值的取值范围依赖于实现, 以下是一些浮点数的例子::

   3.14    10.    .001    1e100    3.14e-10    0e0

Note that numeric literals do not include a sign; a phrase like ``-1`` is
actually an expression composed of the unary operator ``-`` and the literal
``1``.

注意数值型字面值并不包括正负号, 像 ``-1`` , 实际上是一个组合了一元运算符 '``-``' 和字面值``1``的表达式. 

.. _imaginary:

虚数字面值 (Imaginary literals) 
--------------------------------------------------------------

Imaginary literals are described by the following lexical definitions:

虚数字面值可以用下面词法定义描述: 

.. productionlist::
   imagnumber: (`floatnumber` | `intpart`) ("j" | "J")

An imaginary literal yields a complex number with a real part of 0.0.  Complex
numbers are represented as a pair of floating point numbers and have the same
restrictions on their range.  To create a complex number with a nonzero real
part, add a floating point number to it, e.g., ``(3+4j)``.  Some examples of
imaginary literals:

虚数是实部为零的复数. 复数由一对有着相同取值范围的浮点数表示. 为了创建一个非零实部的复数, 可以对它增加一个浮点数, 例如,  ``(3+4j)`` . 下面是一些例子::

   3.14j   10.j    10j     .001j   1e100j  3.14e-10j


.. _operators:

运算符 (Operators) 
====================

.. index:: single: operators

The following tokens are operators:

运算符包括以下语言符号::

   +       -       *       **      /       //      %
   <<      >>      &       |       ^       ~
   <       >       <=      >=      ==      !=


.. _delimiters:

分隔符 (Delimiters) 
======================

.. index:: single: delimiters

The following tokens serve as delimiters in the grammar:

以下符号用作语法上的分隔符::

   (       )       [       ]       {       }
   ,       :       .       ;       @       =
   +=      -=      *=      /=      //=     %=
   &=      |=      ^=      >>=     <<=     **=

The period can also occur in floating-point and imaginary literals.  A sequence
of three periods has a special meaning as an ellipsis literal. The second half
of the list, the augmented assignment operators, serve lexically as delimiters,
but also perform an operation.

句号可以出现在浮点数和虚数字面值中, 三个连续句号的序列是片断的省略写法. 在这个列表的后半部分, 即参数化赋值运算符, 它们在词法上是分隔符, 同时也执行运算. 

The following printing ASCII characters have special meaning as part of other
tokens or are otherwise significant to the lexical analyzer:

以下ASCII可打印字符, 要么在作为其它语言符号的一部分时有特殊含义, 要么对于词法分析器具有特殊作用::

   '       "       #       \

The following printing ASCII characters are not used in Python.  Their
occurrence outside string literals and comments is an unconditional error:

Python不使用以下ASCII可打印字符, 当它们出现在注释和字符串字面值之外时就是非法的::

   $       ?       `

